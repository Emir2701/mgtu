# Каракотова Наталья ИУ7-13Б

# Программа предназначена для создания таблицы значений функций:
# 1) y1 = (x ** 3) + 6.1 * (x ** 2) - 35.4 * x - 25.7
# 2) y2 = (x ** 2) - m.cos(m.pi * x)
# 3) y3 = (y1 ** 2 + y2 ** 2) ** 0.5
# Для построения графика функции: y1 = (x ** 3) + 6.1 * (x ** 2) - 35.4 * x - 25.7
# И для определения количества положительных значений второй функции

# Данные, принимаемые программой:
# start_f – начальное значение аргумента
# end_f – конечное значение аргумента
# step_f – шаг, с которым меняется значение аргумента
# num_serifs – количество засечек

# Переменные для вычислений:
# eps – значение эпсилона, с помощью которого можно сравнивать вещественные числа
# min_f – минимальное значение функции на заданном отрезке
# max_f – максимальное значение функции на заданном отрезке
# count_pos – количество положительных значений второй функции
# len_x – длина значения аргумента
# len_y1 – длина значения первой функции
# len_y2 – длина значения фторой функции
# len_y3 – длина значения третьей функции
# start_sign – количество знаков после запятой у начального значения аргумента
# end_sign – количество знаков после запятой у конечного значения аргумента
# step_sign – количество знаков после запятой у шага
# sign – максимальное количество знаков после запятой
# x – значение аргумента
# y1 – значение функции y1 = (x ** 3) + 6.1 * (x ** 2) - 35.4 * x - 25.7
# y2 – значение функции y2 = (x ** 2) - m.cos(m.pi * x)
# y3 – значение функции y3 = (y1 ** 2 + y2 ** 2) ** 0.5
# x_str – отформатированное строковое представление значения аргумента
# y1_str – отформатированное строковое представление значения первой функции
# y2_str – отформатированное строковое представление значения первой функции
# start_serif – значение первой засечки
# end_serif – значение последней засечки
# step_serif – шаг, с котором меняются значения засечек
# len_s – длина строки с засечками
# dist – расстояние от минимального значения функции до максимального
# min_pos – минимальное положительное значение функции (minimum positive)
# dist_0 – расстояние от минимального значения функции до 0
# width - ширина графика


# Импортирование библиотеки math
import math as m

# Ввод начального значения аргумента, конечного значения аргумента и шага
start_f = float(input('Введите начальное значение аргумента: '))
end_f = float(input('Введите конечное значение аргумента: '))

# Проверка на введенное конечное значение
while not (start_f < end_f):
    print('Конечное значение аргумента должно быть больше начального.')
    end_f = float(input('Введите конечное значение аргумента: '))
    if start_f < end_f:
        break

# Поиск количества знаков после запятой у начального и конечного значений аргумента
start_sign = len(str(start_f - int(start_f))) - 2
end_sign = len(str(end_f - int(end_f))) - 2
 
 # Ввод значения шага   
step_f = float(input('Введите шаг, с которым будет менятся значение аргумента: '))

# Проверка на положительность шага
while not (step_f > 0):
    print('Шаг должен быть положительным.')
    step_f = float(input('Введите шаг, с которым будет менятся значение аргумента: '))
    if step_f > 0:
        break

# Поиск количества знаков после запятой у шага
step_sign = len(str(step_f - int(step_f))) - 2

# Поиск максимального количества знаков после запятой
sign = max(start_sign, end_sign, step_sign)

# Присваиваем эпсилону очень маленькое значение (будем использовать для сравнения значения функции с нулём)
eps = 1e-8

# Присваиваем минимальному и максимальному значениям функции бесконечность со знаком + и -
min_f = float('inf')
max_f = float('-inf')

count_pos = 0

# Минимальная длина значений, так как она вида 0.00
len_x = 4
len_y1 = 4
len_y2 = 4
len_y3 = 4

# Поиск максимальной длины значений для каждого столбца
for i in range(int(start_f * 10**sign), int(end_f * 10**sign) + 1, int(step_f * 10**sign)):
    x = i / (10 ** sign)
    x_str = '{:.2f}'.format(x)
    if len(x_str) > len_x:
        len_x = len(x_str)
    y1 = (x ** 3) + 6.1 * (x ** 2) - 35.4 * x - 25.7
    y1_str = '{:.2f}'.format(y1)
    if len(y1_str) > len_y1:
        len_y1 = len(y1_str) 
    y2 = (x ** 2) - m.cos(m.pi * x)
    y2_str = '{:.2f}'.format(y2)
    if len(y2_str) > len_y2:
        len_y2 = len(y2_str) 
    y3 = m.sqrt(y1 ** 2 + y2 ** 2)
    y3 = '{:.2f}'.format(y3)
    if len(y3) > len_y3:
        len_y3 = len(y3)


# Первая строка таблицы
print('-' * (len_x + len_y1 + len_y2 + len_y3 + (2 * 4) + 5))
print('| ', ' ' * (len_x // 2), 'x', ' ' * (len_x - len_x // 2 - 1), 
     ' | ', ' ' * (len_y1 // 2), 'y1', ' ' * (len_y1 - len_y1 // 2 - 2), 
     ' | ', ' ' * (len_y2 // 2), 'y2', ' ' * (len_y2 - len_y2 // 2 - 2), 
     ' | ', ' ' * (len_y3 // 2), 'y3', ' ' * (len_y3 - len_y3 // 2 - 2), ' |', sep='')
print('-' * (len_x + len_y1 + len_y2 + len_y3 + (2 * 4) + 5))

# Вычисление значений функций и заполнение последующих строк таблицы
for i in range(int(start_f * 10**sign), int(end_f * 10**sign) + 1, int(step_f * 10**sign)):
    x = i / (10**sign)
    x_str = '{:.2f}'.format(x)
    y1 = (x ** 3) + 6.1 * (x ** 2) - 35.4 * x - 25.7
    y1_str = '{:.2f}'.format(y1)
    y2 = (x ** 2) - m.cos(m.pi * x)
    y2_str = '{:.2f}'.format(y2)
    if y2 > 0:
        count_pos += 1
    if y2 > max_f:
        max_f = y2
    if y2 < min_f:
        min_f = y2
    y3 = m.sqrt(y1 ** 2 + y2 ** 2)
    y3 = '{:.2f}'.format(y3)
    print('| ', x_str, ' ' * (len_x - len(x_str)), ' | ', y1_str, ' ' * (len_y1 - len(y1_str)), 
          ' | ', y2_str, ' ' * (len_y2 - len(y2_str)), ' | ', y3, ' ' * (len_y3 - len(y3)), ' |', sep='')
print('-' * (len_x + len_y1 + len_y2 + len_y3 + (2 * 4) + 5))

# Ответ на дополнительное задание
print('Количество положительных значений второй функции: ', count_pos)

# Ввод количества засечек
num_serifs = int(input('Введите количество засечек от четырёх до восьми: '))

# Проверка на количество засечек от 4 до 8
while not (4 <= num_serifs <= 8):
    print('Количество засечек должно быть от четырёх до восьми.')
    num_serifs = int(input('Введите количество засечек от четырёх до восьми: '))
    if 4 <= num_serifs <= 8:
        break

# Ширина графика
width = 150

# Присваивание начального, конечного значений засечек и шага
start_serif = min_f
end_serif = max_f
step_serif = (end_serif - start_serif) / (num_serifs - 1)

len_s = 0

# Вывод строки с засечками
print(' ' * (len_x + 2), end='')
for i in range(num_serifs - 1):
    print('{:.2f}'.format(start_serif), 
          ' ' * ((width - len('{:.2f}'.format(end_serif))) // (num_serifs - 1) - len('{:.2f}'.format(start_serif))), 
          end='', sep='')
    # Суммирование длины каждого вывода
    len_s += len('{:.2f}'.format(start_serif) + \
             ' ' * ((width - len('{:.2f}'.format(end_serif))) // (num_serifs - 1) - len('{:.2f}'.format(start_serif))))
    start_serif += step_serif
print(' ' * (width - len_s - len('{:.2f}'.format(end_serif))), '{:.2f}'.format(end_serif), sep='')

# Вычисление расстояния от минимального значения функции до максимального
dist = max_f - min_f

# Вычисление минимального неотрицательного значения функции
min_pos = min(0, int(min_f))

# Вычисление расстояния от минимального значения функции до нуля
dist_0 = int(width / dist * abs(min_pos))

# Построение графика функции
for i in range(int(start_f * (10**sign)), int(end_f * (10**sign)) + 1, int(step_f * (10**sign))):
    x = i / (10**sign)
    str_x = '{:.2f}'.format(x)
    y2 = (x ** 2) - m.cos(m.pi * x)
    print(str_x, ' ' * (len_x - len(str_x)), ' |', end='', sep='')
    if y2 > 0:
        if min_f < 0:
            print(' ' * dist_0, '|', end='', sep='')
            print(' ' * (int(width / dist * y2) - 1), '*', sep='')
        else:
            print(' ' * (int(width / dist * (y2 - min_f)) - 1), '*', sep='')
    else:
        # Если значение равно 0
        if abs(dist_0 - int(width / dist * abs(y2 - min_f))) < eps:
            print(' ' * int(width / dist * abs(y2 - min_f)), '*', sep='')
        else:
            print(' ' * (int(width / dist * abs(y2 - min_f))), '*', end='', sep='')
            print(' ' * (dist_0 - int(width / dist * abs(y2 - min_f)) - 1), '|', sep='')
