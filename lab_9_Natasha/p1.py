# Каракотова Наталья ИУ7-13Б

# Программа предназначена для создания матрицы с помощью введённых массивов,
# поиска средних арифметических значений положительных чисел каждой строки и
# поиска количества значений, которые меньше среднео арифметического

# Данные принимаемые на вход программой:
# d_count – количество элементов массива D
# f_count – количество элементов массива F

# Переменные функций проверки введённого значения:
# text – приглашение ввода
# type_1 – тип числа, который можно использовать в данном пункте
# n – строка, которую мы проверяем на целочисленнное (и положительное) значение
# dot – массив строки, разделённой точками
# e – массив строки, разделённой е

# Переменные для вычислений:
# d – массив D
# f – массив F
# a – матрица A
# av – массив AV средних арифметических значений положительных чисел в каждой строке
# l – массив L количество чисел, которые меньше, чем среднее арифметическое значение
# count_pos – количество положительных элементов
# summ_pos – сумма положительных элементов 
# count_min – количество элементов, которые меньше, чем среднее арифметическое

# Импортирование синуса из библиотеки math
from math import sin

# Проверка введённого значения
def check_num(text, type_1):
	text_1 = str(input(text))

	while True:
		# Если пустая строка
		if not text_1:
			text_1 = input(text)

		# Если нужно целое положительное число
		if type_1 == '+':
			if positive(text_1):
					return int(text_1)
			else:
				print('Введите целое положительное число.')
				text_1 = input(text)

		# Если нужно число
		elif type_1 == '':
			if is_float(text_1):
					return float(text_1)
			else:
				print('Введите число.')
				text_1 = input(text)
				

# Проверка на целое положительное:
def positive(n):
    # Если у числа есть знак
    if n[0] == '+':
        n = n[1:]
    # Число не ноль
    if n[0] == '0':
    	return False
    return n.isdigit()

# Проверка на вещественное:
def is_float(n):
	# Если у числа есть знак
    if n[0] == '-' or n[0] == '+':
        n = n[1:]
    # Разделяем по точкам
    dot = n.split('.')
    if len(dot) == 1:
    	# Разделяем по e
        e = n.split('e')
        # Если нет e
        if len(e) == 1:
            return n.isdigit()
        # Если есть e
        elif len(e) == 2:
        	# Проверяем правильную расстановку знаков и цифр в экспоненциальном виде
            return (e[0].isdigit() and
            	    e[1] and
                    ((e[1][0] in '+-' and
                     e[1][1:].isdigit()) or
                     e[1].isdigit()))
    # Если число с точкой 
    elif len(dot) == 2:
    	# Разделяем по e
        e = dot[1].split('e')
        # Если нет e
        if len(e) == 1:
            return dot[0].isdigit() and dot[1].isdigit()
        # Если есть e
        elif len(e) == 2:
        	# Проверяем расстановку знаков и цифр в экспоненциальном виде
            return (dot[0].isdigit() and
                    e[0].isdigit() and
                    e[1] and
                    (e[1][0] in '+-' and 
                     e[1][1:].isdigit() or
                     e[1].isdigit()))
    return False

# Заполнение массива D
print()
d_count = check_num('Введите количество элементов в массиве D: ', '+')

d = []

for j in range(d_count):
	d.append(check_num('Введите {:} элемент массива D: '.format(j + 1), ''))

# Заполнение массива F
f_count = check_num('\nВведите количество элементов в массиве F: ', '+')

f = []

for k in range(f_count):
	f.append(check_num('Введите {:} элемент массива F: '.format(k + 1), ''))

# Создание матрицы, массива из средних арифметических положительныхзначений каждой строки
# и массива из количества элементов меньших среднего арифметического в каждой строке
a = []
av = []
l = []

# Заполнение матрицы и массивов
for j in range(len(d)):
	a.append([])
	count_pos = 0
	summ_pos = 0
	for k in range(len(f)):
		elem = sin(d[j] + f[k])
		a[j].append(elem)
		if elem > 0:
			count_pos += 1
			summ_pos += elem
	if count_pos == 0:
		av.append(0)
	else:
		av.append(summ_pos / count_pos)

	count_min = 0
	for k in range(len(f)):
		if a[j][k] < av[j]:
			count_min += 1
	l.append(count_min)

# Вывод 
print('\n Матрица, массив средних арифметических значений положительных чисел \n'
	'и массив количества значений, которые меньше среднего арифметического: \n')
for i in range(len(d)):
	for j in range(len(f)):
		print('{:<11.4}'.format(a[i][j]), end='')
	print('| {:<11.4}'.format(av[i]), '|', l[i])

print()


